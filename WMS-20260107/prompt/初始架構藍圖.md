這是一份經過完整梳理、結合了所有前期討論與決策的 **WMS-Python 系統架構分析總結報告**。此文件將作為專案開發的唯一真理來源 (SSOT)。

---

# WMS-Python 體育用品庫存管理系統 - 架構分析總結報告

## 1. 專案概述 (Overview)

本專案旨在開發一個模組化、可測試且易於擴展的桌面版庫存管理系統。系統專為體育用品零售設計，核心特點是支援「多變體 (Multi-Variant)」商品結構（如：同款鞋子區分不同尺寸/顏色）。

* **技術棧**: Python 3.10+, Tkinter (UI), SQLite (Database)
* **核心架構**: Clean Architecture (整潔架構) + MVP (Model-View-Presenter)
* **開發目標**: 建立 MVP (Minimum Viable Product)，並保留未來擴充性。

---

## 2. 系統架構設計 (System Architecture)

我們採用 **分層架構 (Layered Architecture)**，嚴格遵守依賴反轉原則 (DIP)，由內而外單向依賴。

### A. 分層職責

1. **Domain Layer (企業實體層)** `[最內層]`
* **內容**: 純 Python `dataclasses` (Product, Variant, Document)。
* **規則**: 不依賴任何外部庫 (無 Tkinter, 無 SQL)。定義業務規則（如：安全庫存判斷、變體名稱生成）。


2. **Application Layer (應用邏輯層)**
* **內容**: Services (InventoryService, ReportService)。
* **職責**: 編排業務流程（如：進貨流程 = 建立單據 + 增加庫存）。
* **介面**: 定義 Repositories 的抽象介面 (`IProductRepository`)，供下層實作。


3. **Interface Adapters (介面適配層)**
* **內容**: Presenters (MVP), Repository Implementations (SQL操作)。
* **職責**: 將 UI 事件轉為業務指令；將資料庫資料轉為 Domain 物件。


4. **Infrastructure Layer (框架與驅動層)** `[最外層]`
* **內容**: Tkinter Views, SQLite Drivers, Main Entry。
* **職責**: 啟動程式、繪製像素、持久化資料檔案。



### B. UI 設計模式：Passive View (MVP)

為了極大化 UI 邏輯的可測試性：

* **View (Tkinter)**: 極度「愚笨」。只負責佈局與轉發使用者操作 (`command=presenter.on_click`)，不包含 `if/else` 邏輯。
* **Presenter**: 負責所有 UI 邏輯。例如：決定是否啟用按鈕、驗證輸入資料、呼叫 Service 層、通知 View 顯示錯誤訊息。
* **Model**: 業務資料物件 (Domain Entities)。

---

## 3. 核心領域模型 (Domain Model)

針對體育用品特性，我們確立了 **「款式 (Product) - 變體 (Variant)」** 二級結構。

### 實體關係 (ERD 概念)

1. **Product (商品款式)**
* 代表抽象的產品概念（例如：Nike Air Zoom）。
* 屬性：`Name`, `Brand`, `Category`, `BasePrice`, `Description`.


2. **Variant (庫存變體)**
* 代表實際的庫存單位（SKU）。
* 屬性：`Size`, `Color`, `SkuCode`, `StockQty`, `SafetyStock`.
* **關鍵邏輯**: 庫存數量 (`StockQty`) 綁定在此層級。


3. **Document (單據)**
* 驅動庫存變動的唯一來源。
* 類型：`INBOUND` (進貨), `OUTBOUND` (銷貨), `ADJUST` (調整).
* 包含多個 **DocumentItem** (記錄 Variant ID, 數量, 當下單價)。



---

## 4. 資料庫設計 (SQLite Schema)

```sql
-- 1. 商品款式
CREATE TABLE products (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    brand TEXT NOT NULL,
    category TEXT,
    base_price DECIMAL(10, 2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. 庫存變體 (實際庫存持有者)
CREATE TABLE variants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER NOT NULL,
    size TEXT NOT NULL,
    color TEXT NOT NULL,
    sku TEXT UNIQUE,
    stock_qty INTEGER DEFAULT 0,  -- 快照值
    safety_stock INTEGER DEFAULT 5,
    FOREIGN KEY(product_id) REFERENCES products(id)
);

-- 3. 單據主檔
CREATE TABLE documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    doc_type TEXT NOT NULL, -- 'INBOUND', 'OUTBOUND', 'ADJUST'
    doc_date DATE NOT NULL,
    note TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 4. 單據明細
CREATE TABLE document_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    doc_id INTEGER NOT NULL,
    variant_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10, 2),
    FOREIGN KEY(doc_id) REFERENCES documents(id),
    FOREIGN KEY(variant_id) REFERENCES variants(id)
);

```

---

## 5. 關鍵業務流程與 UI 交互

### A. 進貨/銷貨流程 (Transaction Flow)

1. **選擇商品**: 使用者在下拉選單選擇「品牌」->「商品名稱」。
2. **動態載入變體**: 系統根據 Product ID 撈取對應的 Size/Color 列表，填入第二個下拉選單。
* *技術風險*: 需確保 Presenter 非同步或高效處理，避免 UI 卡頓。


3. **輸入數量**: 填寫數量與單價。
4. **加入清單**: 暫存於記憶體中的 `DraftDocument`。
5. **確認過帳**: 按下「儲存」 -> Service 開啟 DB Transaction -> 寫入 Document/Items -> 更新 Variant `stock_qty` -> Commit。

### B. 庫存查詢

* 支援依「品牌」、「分類」或「低庫存狀態」篩選。
* 列表顯示應聚合顯示：`商品名稱 | 變體規格 | 當前庫存 | 狀態(正常/低水位)`。

---

## 6. 專案目錄結構 (Directory Structure)

```text
WMS-Python/
├── src/
│   ├── main.py                # 程式進入點 (Composition Root)
│   ├── config.py              # 設定 (DB路徑等)
│   ├── domain/                # [內層] 實體與業務異常
│   │   ├── models.py          # Product, Variant, Document (Dataclasses)
│   │   └── exceptions.py      # OutOfStockError, InvalidSkuError
│   ├── application/           # [中層] 使用案例
│   │   ├── services.py        # InventoryService
│   │   └── interfaces.py      # IRepository 介面定義
│   ├── infrastructure/        # [外層] 實作
│   │   ├── database.py        # SQLite 連線管理
│   │   └── repositories.py    # SqliteProductRepository
│   └── interface/             # [外層] UI (Tkinter)
│       ├── app.py             # 主視窗容器
│       ├── views/             # 具體畫面 (Frame)
│       ├── presenters/        # 畫面邏輯
│       └── widgets/           # 共用元件 (Ex: AutoScrollbar)
├── tests/
│   ├── unit/                  # 針對 Domain/Application 的測試 (Mock DB)
│   └── integration/           # 針對 Repository 的測試 (Real DB)
├── assets/                    # 圖示、資源
└── requirements.txt

```

---

## 7. 開發規範摘要 (Coding Standards)

為了確保程式碼品質，全體開發需遵守 `.cursorrules` 定義之規範：

1. **型別安全**: 全面使用 Type Hints (`def func(a: int) -> bool:`)，嚴禁 `Any`。
2. **命名慣例**:
* 變數/函式: `snake_case`
* 類別: `PascalCase`
* 介面: `I` 開頭 (如 `IProductRepository`)
* Tkinter 元件: 需帶後綴 (如 `_btn`, `_lbl`, `_entry`)


3. **錯誤處理**:
* Repository 層捕捉 `sqlite3.Error` -> 轉拋 Domain Exception。
* Presenter 層捕捉所有異常 -> 呼叫 View 顯示錯誤視窗 -> 寫入 Log。


4. **文件**: Public Methods 需撰寫 Google Style Docstrings (繁體中文)。
5. **測試**: 使用 `pytest`，業務邏輯層需達 100% 覆蓋率。

這份報告總結了我們目前的架構共識。接下來我們可以依據此藍圖，從 **Infrastructure (Database)** 層開始進行程式碼實作。

* 更新於2026/1/2